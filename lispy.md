# IEval: Lispy self-evaluation | вычислимость объектного графа в Лисп-стиле

[IEval methods reference](group__eval.html)

> [Greenspun's tenth rule](https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule):
> Any sufficiently complicated C or Fortran program contains an ad hoc,
> informally-specified, bug-ridden, slow implementation of half of Common Lisp.

> [Десятое правило Гринспена](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%81%D1%8F%D1%82%D0%BE%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%93%D1%80%D0%B8%D0%BD%D1%81%D0%BF%D0%B5%D0%BD%D0%B0) (зелёной ложки):
> Любая достаточно сложная программа на Си или Фортране содержит заново
> написанную, неспецифицированную, глючную и медленную реализацию половины языка
> Common Lisp.

> следствие Армстронга:
> Любая достаточно сложная распределённая программа содержит заново написанную,
> неспецифицированную, глючную и медленную реализацию половины языка Erlang.

Смысл правила в том, что программисты, ограниченные низкоуровневыми языками
вроде Си, или неудачно спроектированными скриптовыми языками, преодолевают
ограничения языка путём введения в текст программ аналогов свойств, присущих
более выразительным языкам вроде Лиспа. В более общем виде -- любая более или
менее сложная система, которую стремятся сделать конфигурируемой или гибкой,
стремится превратиться в скриптовый движок. *Если команда разработки стремится к
минимализму в ущерб привычному синтаксису*, интерпретатор в большей или меньшей
степени получается похожим на Лисп.


[SICP Chapter 4 Metalinguistic Abstraction](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-25.html#%_chap_4)

Первоначальной целью `metaL` было декларативное описание компонентов
программного обеспечения в функциональном стиле, но стремление к большей
гибкости и при этом сохранении простоты навевает мысли об использовании
Лисп-подходов. Реализация магии `eval`/`apply` реализована в зачаточном
состоянии, так как упор в первую очередь делается на предоставлении богатой базы
для создания веб-приложений. С другой стороны, конфигурирование пользователем
предполагает наличие некоторой "песочницы" со своим скриптовым языком, и
естественен интерес к применению "скобочного" языка а-ля
[Clojure](http://alexott.net/ru/clojure/clojure-intro/), поверх объектного
pythonic рантайма.

## перевод видеолекций MIT [Структура и Интерпретация Компьютерных Программ (SICP)](https://www.youtube.com/playlist?list=PLc6AqfeLgwzPPK1H3XV1Wfb_CGvT6sXkC)
